<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Phil Elson - Software | Science | Python - field-notes</title><link href="https://pelson.github.io/" rel="alternate"></link><link href="https://pelson.github.io/feeds/field-notes.atom.xml" rel="self"></link><id>https://pelson.github.io/</id><updated>2019-02-15T00:00:00+00:00</updated><entry><title>cf-units get (La)TeX unit repr... and a UDUNITS-2 parser to boot</title><link href="https://pelson.github.io/2019/cf_units_tex/" rel="alternate"></link><published>2019-02-15T00:00:00+00:00</published><updated>2019-02-15T00:00:00+00:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2019-02-15:2019/cf_units_tex/</id><summary type="html">&lt;p&gt;I recently worked on a feature to allow &lt;a href="https://github.com/SciTools/cf-units"&gt;cf-units&lt;/a&gt; to produce a &lt;a href="https://en.wikipedia.org/wiki/TeX"&gt;TeX&lt;/a&gt; representation of a unit so that it can be quickly copy-and-pasted into a LaTeX document, or simply visualised nicely with &lt;a href="https://matplotlib.org/users/usetex.html"&gt;matplotlib's LaTeX writer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It turns out that "doing it right" was quite involved, and has ultimately led …&lt;/p&gt;</summary><category term="cf-units"></category><category term="UDUNITS-2"></category></entry><entry><title>Investigating containment testing on LFRic's cubedsphere</title><link href="https://pelson.github.io/2018/LFRic_containment/" rel="alternate"></link><published>2018-05-29T00:00:00+01:00</published><updated>2018-05-29T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2018-05-29:2018/LFRic_containment/</id><summary type="html">&lt;p&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h1 id="UGRID-and-LFRic:-Polygon-mesh-intersections"&gt;UGRID and LFRic: Polygon mesh intersections&lt;a class="anchor-link" href="#UGRID-and-LFRic:-Polygon-mesh-intersections"&gt;&amp;#182;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;I'm aiming to investigate whether it is possible to use the existing python tools to compute intersections of cells definied on the Met Office's &lt;a href="https://www.metoffice.gov.uk/research/modelling-systems/lfric"&gt;LFRic&lt;/a&gt; cubesphere. A (possibly out of date but still enlightening) presentation about the LFRic datamodel can also be found &lt;a href="https://is.enes.org/documents/Talks/crossing-the-chasm/mullerworth_data-models-within-lfric"&gt;here …&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;</summary><category term="LFRic"></category><category term="cartopy"></category><category term="shapely"></category><category term="xarray"></category></entry><entry><title>Analysing walks on the South West Coast Path</title><link href="https://pelson.github.io/2018/coast-path/" rel="alternate"></link><published>2018-05-26T00:00:00+01:00</published><updated>2018-05-26T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2018-05-26:2018/coast-path/</id><summary type="html">&lt;p&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;I'm fortunate to live near to one of the best continuous coastal walking/hiking routes in the world. The UK's &lt;a href="https://www.southwestcoastpath.org.uk/"&gt;South West Coast Path&lt;/a&gt; is a scenic, cultural and culinary delight spanning 630 miles from Minehead to Poole. It is steeped with history, and apparently was originally created by the …&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;</summary><category term="fiona"></category><category term="shapely"></category><category term="folium"></category><category term="cartopy"></category></entry><entry><title>Creating a continuous integration service to check CLAs on GitHub</title><link href="https://pelson.github.io/2017/scitools_cla_service/" rel="alternate"></link><published>2017-08-13T00:00:00+01:00</published><updated>2017-08-13T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-08-13:2017/scitools_cla_service/</id><summary type="html">&lt;p&gt;Contributor license agreements are a thing. As much as I dislike the bureaucracy of them, they do provide some additional cover
to the owners of an open source project, and some companies insist on having them. I find myself in such a situation in the
&lt;a href="https://github.com/SciTools"&gt;SciTools&lt;/a&gt; organisation, for which I …&lt;/p&gt;</summary><category term="GitHub"></category><category term="CLA"></category><category term="heroku"></category><category term="tornado"></category></entry><entry><title>Converting rasters to SVG, and creating a rudimentary font with font-forge - Part 4 of an XKCD font saga</title><link href="https://pelson.github.io/2017/xkcd_font_raster_to_vector_and_basic_font_creation/" rel="alternate"></link><published>2017-04-21T00:00:00+01:00</published><updated>2017-04-21T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-04-21:2017/xkcd_font_raster_to_vector_and_basic_font_creation/</id><summary type="html">&lt;p&gt;In &lt;a href="https://pelson.github.io/2017/xkcd_font_classifying_strokes/"&gt;part three&lt;/a&gt; of my XKCD font saga I generated several hundred glyphs as PPM images, and
classified them with their associated character(s). In this instalment, I will convert the raster glyphs into vector form (SVG) and then
generate a rudimentary font using FontForge.&lt;/p&gt;


&lt;p&gt;If you'd like to follow …&lt;/p&gt;</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Classifying segmented strokes as characters - Part 3 of an XKCD font saga</title><link href="https://pelson.github.io/2017/xkcd_font_classifying_strokes/" rel="alternate"></link><published>2017-04-01T00:00:00+01:00</published><updated>2017-04-01T00:00:00+01:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-04-01:2017/xkcd_font_classifying_strokes/</id><summary type="html">&lt;p&gt;In &lt;a href="https://pelson.github.io/2017/xkcd_font_merge_then_extract_glyphs/"&gt;part two&lt;/a&gt; of my XKCD font saga I was able to separate strokes from the XKCD
handwriting dataset into many smaller images. I also handled the easier cases of merging some of the strokes back together - I particularly
focused on "dotty" or "liney" type glyphs, such as i, !, % and …&lt;/p&gt;</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Segment, extract, and combine features of an image with SciPy and scikit-image - Part 2 of an XKCD font saga</title><link href="https://pelson.github.io/2017/xkcd_font_merge_then_extract_glyphs/" rel="alternate"></link><published>2017-03-20T00:00:00+00:00</published><updated>2017-03-20T00:00:00+00:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-03-20:2017/xkcd_font_merge_then_extract_glyphs/</id><summary type="html">&lt;p&gt;In &lt;a href="https://pelson.github.io/2017/xkcd_font/"&gt;part one&lt;/a&gt; of XKCD font saga I gave some background on the XKCD handwriting dataset, and took an initial look at image
segmentation in order to extract the individual strokes from the scanned image.
In this instalment, I will apply the technique from part 1, as well as attempting …&lt;/p&gt;</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Playing with Randall Munroe's XKCD handwriting</title><link href="https://pelson.github.io/2017/xkcd_font/" rel="alternate"></link><published>2017-03-16T00:00:00+00:00</published><updated>2017-03-16T00:00:00+00:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-03-16:2017/xkcd_font/</id><summary type="html">&lt;p&gt;The XKCD font (as used by matplotlib et al.) recently &lt;a href="https://github.com/ipython/xkcd-font/pull/13"&gt;got an update&lt;/a&gt; to include lower-case characters.
For some time now I have been aware of a handwriting sample produced by Randall Munroe (XKCD's creator) that I was interested in exploring.
The ultimate aim is to automatically produce a font-file …&lt;/p&gt;</summary><category term="XKCD"></category><category term="fonts"></category><category term="Python"></category></entry><entry><title>Mounting a FUSE filesystem in Heroku</title><link href="https://pelson.github.io/2017/heroku_fuse_mount/" rel="alternate"></link><published>2017-02-06T00:00:00+00:00</published><updated>2017-02-06T00:00:00+00:00</updated><author><name>Phil Elson</name></author><id>tag:pelson.github.io,2017-02-06:2017/heroku_fuse_mount/</id><summary type="html">&lt;p&gt;This evening I'm going to take a different approach to how I would normally blog.&lt;/p&gt;
&lt;p&gt;Rather than reporting the results of a technical investigation or highlighting a new/shiny package, I wanted to
paint a realistic picture of the technical exploration process.&lt;/p&gt;
&lt;p&gt;As it happens, this particular investigation consumed a …&lt;/p&gt;</summary><category term="Heroku"></category><category term="FUSE"></category><category term="python"></category><category term="docker"></category></entry></feed>